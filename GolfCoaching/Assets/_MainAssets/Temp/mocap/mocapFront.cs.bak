using UnityEngine;
using System;
using System.IO;
using System.IO.Pipes;
using System.Threading;
using System.Collections.Generic;
using Newtonsoft.Json;
using System.Collections;
using TMPro;
using Unity.VisualScripting;

public class mocapFront : MonoBehaviour
{
    //private static object syncRootObject = new object();

    private Queue<Vector3>[] positionHistory = new Queue<Vector3>[33];
    private const int historyLength = 5; // 이동 평균을 위한 히스토리 길이
    private Vector3[] lastValidPositions = new Vector3[33];
    private const float maxAllowedChange = 0.1f; // 한 프레임당 최대 허용 변화량

    [SerializeField] float smoothness = 0.1f;
    [SerializeField] private GameObject[] positionTest = new GameObject[33];
    //public int visibleCount = 0;

    // 생성자 또는 Start 메서드에서 칼만 필터 초기화
    private void InitializeKalmanFilters()
    {
        for (int i = 0; i < 33; i++)
        {
            kalmanFilters[i] = new KalmanFilter[3];
            for (int j = 0; j < 3; j++)
            {
                kalmanFilters[i][j] = new KalmanFilter();
            }
        }
    }

    private KalmanFilter[][] kalmanFilters = new KalmanFilter[33][];
    public string PIPE_NAME = "skeleton_pipe1";
    bool CAMSWAP = false;
    //public float AdjustAngleX = 0;
    //public float AdjustAngleY = 0;
    //Quaternion rotationX;
    //Quaternion rotationY;
    //private const string PIPE_NAME = "MediaPipePoseEstimation";
    private Thread pipeClientThread;
    private bool isRunning = false;
    private Dictionary<string, PoseLandmark> poseData = new Dictionary<string, PoseLandmark>();
    private bool isConnected = false;

    [SerializeField] TextMeshProUGUI txtHandVIsible;

    //[SerializeField] TMP_InputField txtAngleX;
    //[SerializeField] TMP_InputField txtAngleY;

    string format = "RH:{0}\r\nLH:{1}\r\nHD:{2}\r\nSA:{3}\r\nPA:{4}\r\nbackboneA:{5}";

    [SerializeField] TextMeshProUGUI PipeName;

    [Serializable]
    public class PoseLandmark
    {
        public float x;
        public float y;
        public float z;
        public float visibility;
    }

    Vector3 handVector = Vector3.zero;

    public float PelvisValue = 0;
    public float ShoulderValue = 0;

    private void Start()
    {
        InitializeKalmanFilters();

        CAMSWAP = PlayerPrefs.GetInt("CAMSWAP", 0) == 0 ? false : true;

        PIPE_NAME = CAMSWAP ? "skeleton_pipe2" : "skeleton_pipe1";

        Debug.Log($"{gameObject.name} CAMSWAP : {CAMSWAP} / PIPE : {PIPE_NAME}");

        PipeName.text = PIPE_NAME;

        StartPipeClient();

        //mocap씬
        StartMatchPose();
    }

    private void OnDestroy()
    {
        StopPipeClient();
    }

    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
            Application.Quit();
    }

    private void StartPipeClient()
    {
        isRunning = true;
        pipeClientThread = new Thread(PipeClientThread);
        pipeClientThread.Start();
    }

    public void OnClick_CamSwap()
    {
        CAMSWAP = !CAMSWAP;
        PlayerPrefs.SetInt("CAMSWAP", CAMSWAP ? 1 : 0);
    }

    private void StopPipeClient()
    {
        isRunning = false;
        if (pipeClientThread != null)
        {
            pipeClientThread.Join();
        }
    }

    private void PipeClientThread()
    {
        while (isRunning)
        {
            try
            {
                Debug.Log("서버 연결을 대기 중입니다...");
                using (NamedPipeClientStream pipeClient = new NamedPipeClientStream(".", PIPE_NAME, PipeDirection.In))
                {
                    pipeClient.Connect(5000); // 5초 타임아웃
                    isConnected = true;
                    Debug.Log("서버와 연결되었습니다.");

                    using (StreamReader sr = new StreamReader(pipeClient))
                    {
                        while (isRunning)
                        {
                            if (pipeClient.IsConnected)
                            {
                                string message = sr.ReadLine();
                                //Debug.Log($"Raw received data: {message.Length}");
                                //if (message.Length > 5000)
                                //    continue;
                                //Debug.Log($"Raw received data: {message}");  // 추가된 로그
                                if (!string.IsNullOrEmpty(message))
                                {
                                    ProcessPoseData(message);
                                }
                                else
                                {
                                    //Debug.LogWarning("Received empty message");  // 추가된 로그
                                }
                            }
                            else
                            {
                                Debug.LogWarning("파이프 연결이 끊어졌습니다. 재연결을 시도합니다.");
                                //isConnected = false;
                                break;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError($"파이프 클라이언트 오류: {e.Message}\n스택 트레이스: {e.StackTrace}");
                if (isConnected)
                {
                    Debug.Log("서버와의 연결이 끊어졌습니다.");
                    isConnected = false;
                }
                Thread.Sleep(1000); // 재연결 전 1초 대기
            }
        }
    }

    private void ProcessPoseData(string jsonData)
    {
        try
        {
            //Debug.Log($"Received JSON data: {jsonData}");
            Dictionary<string, PoseLandmark> newPoseData = JsonConvert.DeserializeObject<Dictionary<string, PoseLandmark>>(jsonData);
            //Debug.Log($"Parsed pose data count: {newPoseData.Count}");
            lock (poseData)
            {
                poseData = newPoseData;
                //Debug.Log($"포즈 데이터 처리 성공: {jsonData}");
            }
        }
        catch (Exception e)
        {
            //Debug.LogError($"포즈 데이터 처리 오류: {e.Message}\n스택 트레이스: {jsonData}");
        }
    }

    /*private void Update()
    {
        //UpdateCharacterPose();
        UpdateBodyTransform();
    }*/

    public Vector3[] updatedJointPositions = new Vector3[33];

    private Vector3 LimitPositionChange(Vector3 oldPosition, Vector3 newPosition, float maxChange)
    {
        Vector3 change = newPosition - oldPosition;
        float magnitude = change.magnitude;
        if (magnitude > maxChange)
        {
            change = change.normalized * maxChange;
        }
        return oldPosition + change;
    }

    private Vector3 CalculateAverage(Queue<Vector3> positions)
    {
        Vector3 sum = Vector3.zero;
        foreach (Vector3 pos in positions)
        {
            sum += pos;
        }
        return sum / positions.Count;
    }

    private void UpdatePositionTest(Vector3[] positions)
    {
        //Debug.Log($"UpdatePositionTest : {positionTest.Length}");
        for (int i = 0; i < positionTest.Length && i < positions.Length; i++)
        {
            if (positionTest[i] != null)
            {
                // 좌우 반전 및 위아래 뒤집기
                Vector3 flippedPosition = new Vector3(-positions[i].x, positions[i].y, positions[i].z);
                positionTest[i].transform.position = Vector3.Lerp(positionTest[i].transform.position, flippedPosition, characterpose.Instance.smoothness);
                updatedJointPositions[i] = flippedPosition;
            }
        }
        characterpose.Instance.UpdateBodyPositions(updatedJointPositions);
    }


    void UpdateBodyTransform()
    {
        float rHandVis = 0, lHandVis = 0;

        lock (poseData)
        {
            //string rh = "", lh = "";
            //string rk = "", lk = "";

            for (int i = 0; i < 33; i++)
            {
                string key = $"landmark_{i}";
                if (poseData.TryGetValue(key, out PoseLandmark landmark))
                {
                    if (i == 18) rHandVis = landmark.visibility;
                    else if (i == 17) lHandVis = landmark.visibility;
                    //if (i == 18) rh = landmark.visibility.ToString("0.00");
                    //if (i == 17) lh = landmark.visibility.ToString("0.00");
                    //if (i == 26) rk = landmark.y.ToString("0.00");
                    //if (i == 25) lk = landmark.y.ToString("0.00");

                    Vector3 newPosition = Vector3.zero;

                    newPosition = new Vector3(
                        kalmanFilters[i][0].Update(landmark.x),
                        -kalmanFilters[i][1].Update(landmark.y),
                        kalmanFilters[i][2].Update(landmark.z)
                    );

                    // 초기화
                    if (positionHistory[i] == null)
                    {
                        positionHistory[i] = new Queue<Vector3>();
                        lastValidPositions[i] = newPosition;
                    }

                    // 급격한 변화 제한
                    Vector3 limitedPosition = LimitPositionChange(lastValidPositions[i], newPosition, maxAllowedChange);

                    // 이동 평균 필터 적용
                    positionHistory[i].Enqueue(limitedPosition);
                    if (positionHistory[i].Count > historyLength)
                    {
                        positionHistory[i].Dequeue();
                    }

                    Vector3 averagePosition = CalculateAverage(positionHistory[i]);

                    updatedJointPositions[i] = averagePosition;
                    lastValidPositions[i] = averagePosition;
                }
            }
            //txtHandVIsible.text = string.Format(format, rh, lh);
            //txtHandVIsible.text = string.Format(format, rHandVis, lHandVis, GetHandDistance(), (GetShoulderDir() * 180f), (GetPelvisDir() * 180f));
            txtHandVIsible.text = string.Format(format, rHandVis, lHandVis, GetHandDistance(), (GetShoulderDir() * 180f), (GetPelvisDir() * 180f), GetBackboneDir());
        }

        for (int i = 0; i < positionTest.Length && i < updatedJointPositions.Length; i++)
        {
            if (positionTest[i] != null)
            {
                // 좌우 반전 및 위아래 뒤집기
                Vector3 flippedPosition = new Vector3(-updatedJointPositions[i].x, updatedJointPositions[i].y, updatedJointPositions[i].z);
                positionTest[i].transform.position = Vector3.Lerp(positionTest[i].transform.position, flippedPosition, this.smoothness);
                updatedJointPositions[i] = flippedPosition;
            }
        }

        if (rHandVis > lHandVis)
            handVector = positionTest[18].transform.position;
        else
            handVector = positionTest[17].transform.position;
    }


    private void PrintPoseData()
    {
        UnityEngine.Debug.Log
            (
                message: "mocap.cs - Line 268\n" +
                $@"poseData.Count : {poseData.Count}"
            );
        lock (poseData)
        {
            if (poseData.Count > 0)
            {
                Debug.Log("현재 포즈 데이터:");
                foreach (var kvp in poseData)
                {
                    Debug.Log($"{kvp.Key}: X={kvp.Value.x}, Y={kvp.Value.y}, Z={kvp.Value.z}, Visibility={kvp.Value.visibility}");
                }
            }
        }
    }

    IEnumerator CoStartMatchPose()
    {
        while (true)
        {
            UpdateBodyTransform();
            yield return null;
        }
    }

    public void StartMatchPose()
    {
        StartCoroutine(CoStartMatchPose());
    }

    public void StopMatchPose()
    {
        StopAllCoroutines();
        Reset();
    }


    public void Reset()
    {
        foreach (var data in poseData)
        {
            data.Value.x = 0;
            data.Value.y = 0;
            data.Value.z = 0;
            data.Value.visibility = 0;
        }

        for (int i = 0; i < positionTest.Length; i++)
        {
            positionTest[i].transform.position = Vector3.zero;
        }
    }

    public Dictionary<string, PoseLandmark> GetPoseData()
    {
        return poseData;
    }

    //스윙 각도
    public float GetHandDir()
    {
        // 어꺠중심과 손중심을 기준
        Vector3 shoulderVector = (positionTest[12].transform.position + positionTest[11].transform.position) / 2;
        //Vector3 handVector = (positionTest[18].transform.position + positionTest[17].transform.position) / 2;
        Vector3 dir = handVector - shoulderVector;
        dir.z = 0;

        // 어깨 벡터와 손 벡터 간의 각도 계산
        return 360 - Quaternion.FromToRotation(Vector3.up, dir).eulerAngles.z;
    }

    //양손 거리
    public float GetHandDistance()
    {
        return Vector3.Distance(positionTest[18].transform.position, positionTest[17].transform.position);
    }

    //어께 회전
    public float GetShoulderDir()
    {
        /*
        // 골반의 중앙을 기준으로 하는 벡터 계산
        Vector3 PelvisVector = (positionTest[24].transform.position - positionTest[23].transform.position) / 2f;
        Vector3 shoulderVector = (positionTest[12].transform.position - positionTest[11].transform.position) / 2f;

        // 어깨 벡터와 골반 벡터 간의 회전 각도 계산
        float angle = Vector3.SignedAngle(PelvisVector, shoulderVector, Vector3.forward);
        return angle / 180f;
        */
        // 골반의 중앙을 기준으로 하는 벡터 계산
        Vector3 PelvisVector = (new Vector3(positionTest[24].transform.position.x, 0, positionTest[24].transform.position.z)
            - new Vector3(positionTest[23].transform.position.x, 0, positionTest[23].transform.position.z)).normalized;
        Vector3 shoulderVector = (new Vector3(positionTest[12].transform.position.x, 0, positionTest[12].transform.position.z)
            - new Vector3(positionTest[11].transform.position.x, 0, positionTest[11].transform.position.z)).normalized;

        // 어깨 벡터와 골반 벡터 간의 회전 각도 계산
        float angle = Vector3.SignedAngle(PelvisVector, shoulderVector, Vector3.up);
        ShoulderValue = angle / 180f;
        return ShoulderValue;
    }

    //골반 회전
    public float GetPelvisDir()
    {
        /*
        // 양발의 중앙을 기준으로 하는 벡터 계산
        Vector3 FootVector = (positionTest[28].transform.position - positionTest[27].transform.position) / 2f;
        Vector3 PelvisVector = (positionTest[24].transform.position - positionTest[23].transform.position) / 2f;
        FootVector.z = 0;
        PelvisVector.z = 0;

        // 골반 벡터와 양발 벡터 간의 회전 각도 계산
        float angle = Vector3.SignedAngle(FootVector, PelvisVector, Vector3.forward);
        PelvisValue = angle / 180f;        
        return PelvisValue;
        */
        Vector3 PelvisVector = (new Vector3(positionTest[24].transform.position.x, 0, positionTest[24].transform.position.z)
            - new Vector3(positionTest[23].transform.position.x, 0, positionTest[23].transform.position.z)).normalized;
        Vector3 FootVector = (new Vector3(positionTest[28].transform.position.x, 0, positionTest[28].transform.position.z)
            - new Vector3(positionTest[27].transform.position.x, 0, positionTest[27].transform.position.z)).normalized;

        // 어깨 벡터와 골반 벡터 간의 회전 각도 계산
        float angle = Vector3.SignedAngle(FootVector, PelvisVector, Vector3.up);
        PelvisValue = angle / 180f;
        return PelvisValue;
    }

    public float GetBackboneDir()
    {
        Vector3 shoulderCenter = Utillity.GetCenter(positionTest[11].transform.position, positionTest[12].transform.position);
        Vector3 hipCenter = Utillity.GetCenter(positionTest[23].transform.position, positionTest[24].transform.position);

        return Utillity.GetAngle(shoulderCenter, hipCenter);
    }
}